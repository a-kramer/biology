package util;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.stream.XMLStreamException;

import model.ODEModel;

import org.sbml.jsbml.ASTNode;
import org.sbml.jsbml.SBMLDocument;
import org.sbml.jsbml.SBMLReader;

import parser.TraceParser;

public class Utility {

	public static String writeSMT2ToString(ModelSettings settings) throws XMLStreamException,
			IOException {
		return writeSMT2ToString(SBMLReader.read(new File(settings.getSBMLFile())),
				TraceParser.parseCopasiOutput(new File(settings.getTimeSeriesFile())), null);
	}

	/**
	 * 
	 * Returns a String representation of the provided SBML document as an ODE model in the SMT2
	 * format. This method additionally takes a property to be checked as a parameter and adds it to
	 * the SMT2 file so that it can be checked with a SMT2 solver.
	 * 
	 * @param document
	 *            - the SBML document to be translated into the ODE model
	 * @param trace
	 *            - time series data for the SBML document
	 * @param property
	 *            - the property that is added the the SMT2 file
	 * @return A string representation of the SMT2 file generated by converting the SBML file into
	 *         the SMT2 file
	 */
	public static String writeSMT2ToString(SBMLDocument document, Trace trace, ASTNode property) {
		String output = ";This file was generated from the SBML model:  "
				+ document.getModel().getId() + "\n";
		output += "(set-logic QF_NRA_ODE)\n";
		ODEModel odeModel = new ODEModel(document);
		output += "(declare-fun t () Real)\n";
		if (trace != null) {
			for (int i = 0; i < trace.getTimePoints().length; i++) {
				output += "(declare-fun t_" + i + " () Real)\n";
				output += "(declare-fun time_" + i + " () Real)\n";
			}
		}
		else {
			output += "(declare-fun t_0 () Real)\n";
			output += "(declare-fun t_t () Real)\n";
			output += "(declare-fun time_0 () Real)\n";
		}
		for (String variable : odeModel.getArrayOfVariables()) {
			output += "(declare-fun " + variable + " () Real)\n";
			if (trace != null) {
				for (int i = 0; i < trace.getTimePoints().length; i++) {
					output += "(declare-fun " + variable + "_" + i + " () Real)\n";
				}
			}
			else {
				output += "(declare-fun " + variable + "_0 () Real)\n";
				output += "(declare-fun " + variable + "_t () Real)\n";
			}
		}
		output += "(define-ode flow_1 ((= d/dt[t] 1)";
		String vars = "t";
		for (String variable : odeModel.getArrayOfVariables()) {
			output += " (= d/dt[" + variable + "] "
					+ prefixASTNodeToString(odeModel.getODE(variable)) + ")";
			vars += " " + variable;
		}
		output += "))\n";
		if (trace != null) {
			for (String variable : trace.getVariables()) {
				for (String var : odeModel.getArrayOfVariables()) {
					if (var.equals(variable)) {
						for (int i = 0; i < trace.getValues(variable).length; i++) {
							output += "(assert (>= " + variable + "_" + i + " "
									+ trace.getValues(variable)[i] + "))\n";
							output += "(assert (<= " + variable + "_" + i + " "
									+ trace.getValues(variable)[i] + "))\n";
						}
						break;
					}
				}
			}
			for (int i = 0; i < trace.getTimePoints().length; i++) {
				output += "(assert (>= time_" + i + " " + trace.getTimePoints()[i] + "))\n";
				output += "(assert (<= time_" + i + " " + trace.getTimePoints()[i] + "))\n";
				output += "(assert (>= t_" + i + " " + trace.getTimePoints()[i] + "))\n";
				output += "(assert (<= t_" + i + " " + trace.getTimePoints()[i] + "))\n";
				if (i != trace.getTimePoints().length - 1) {
					output += "(assert (= [" + vars.replaceAll(" ", "_" + (i + 1) + " ")
							+ "] (integral 0. time_" + i + " ["
							+ vars.replaceAll(" ", "_" + i + " ") + "] flow_1)))\n";
				}
			}
		}
		else {
			for (String variable : odeModel.getArrayOfVariables()) {
				output += "(assert (>= " + variable + "_0 " + odeModel.getInitialValue(variable)
						+ "))\n";
				output += "(assert (<= " + variable + "_0 " + odeModel.getInitialValue(variable)
						+ "))\n";
			}
			output += "(assert (= [" + vars.replaceAll(" ", "_t ") + "] (integral 0. time_0 ["
					+ vars.replaceAll(" ", "_0 ") + "] flow_1)))\n";
		}
		if (property != null) {
			output += "(assert " + prefixASTNodeToString(property) + ")\n";
		}
		output += "(check-sat)\n(exit)\n";
		return output;
	}

	/**
	 * 
	 * Writes an SMT2 file to the given filename that is generated by converting the provided SBML
	 * document intos an ODE model. This method additionally takes a property to be checked as a
	 * parameter and adds it to the SMT2 file so that it can be checked with a SMT2 solver.
	 * 
	 * @param document
	 *            - the SBML document to be translated into the ODE model
	 * @param trace
	 *            - time series data for the SBML document
	 * @param property
	 *            - the property that is added the the SMT2 file
	 * @param filename
	 *            - the filename that the SMT2 file should be written to
	 */
	public static void writeSMT2(SBMLDocument document, Trace trace, ASTNode property,
			String filename) throws IOException {
		FileOutputStream output = new FileOutputStream(filename);
		String smtFile = writeSMT2ToString(document, trace, property);
		output.write(smtFile.getBytes());
		output.flush();
		output.close();
	}

	/**
	 * 
	 * Returns an ASTNode representing the given String in prefix notation form.
	 * 
	 * @param math
	 *            - the String equation to convert into an ASTNode
	 * @return The ASTNode representing the given String in prefix notation form
	 */
	public static ASTNode prefixStringToASTNode(String math) {
		if (!math.contains(" ")) {
			try {
				int n = Integer.parseInt(math);
				return new ASTNode(n);
			}
			catch (Exception e) {
			}
			try {
				double n = Double.parseDouble(math);
				return new ASTNode(n);
			}
			catch (Exception e) {
			}
			if (math.length() == 1) {
				char c = math.charAt(0);
				if (Character.isAlphabetic(c)) {
					return new ASTNode(math);
				}
				else {
					return new ASTNode(c);
				}
			}
			return new ASTNode(math);
		}
		List<String> tokens = new ArrayList<String>();
		if (math.startsWith("(") && math.endsWith(")")) {
			math = math.substring(1, math.length() - 1);
		}
		int parenCounter = 0;
		String token = "";
		for (char c : math.toCharArray()) {
			if (c == ' ' && parenCounter == 0) {
				tokens.add(token);
				token = "";
			}
			else {
				token += c;
				if (c == '(') {
					parenCounter++;
				}
				else if (c == ')') {
					parenCounter--;
				}
			}
		}
		if (!token.equals("")) {
			tokens.add(token);
		}
		ASTNode node = null;
		if (tokens.size() > 0) {
			node = prefixStringToASTNode(tokens.get(0));
		}
		for (int i = 1; i < tokens.size(); i++) {
			node.addChild(prefixStringToASTNode(tokens.get(i)));
		}
		return node;
	}

	/**
	 * 
	 * Returns a String representation of the given ASTNode equation in prefix notation form.
	 * 
	 * @param math
	 *            - the equation to convert to prefix notation
	 * @return The prefix notation String representation of the provided equation
	 */
	public static String prefixASTNodeToString(ASTNode math) {
		if (math.getType() == ASTNode.Type.CONSTANT_E) {
			return "exponentiale";
		}
		else if (math.getType() == ASTNode.Type.CONSTANT_FALSE) {
			return "false";
		}
		else if (math.getType() == ASTNode.Type.CONSTANT_PI) {
			return "pi";
		}
		else if (math.getType() == ASTNode.Type.CONSTANT_TRUE) {
			return "true";
		}
		else if (math.getType() == ASTNode.Type.DIVIDE) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(/ " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION) {
			String result = "( " + math.getName();
			for (int i = 0; i < math.getChildCount(); i++) {
				String child = prefixASTNodeToString(math.getChild(i));
				result += child;
				if (i + 1 < math.getChildCount()) {
					result += " ";
				}
			}
			result += ")";
			return result;
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ABS) {
			return "(abs " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCCOS) {
			return "(acos " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCCOSH) {
			return "(acosh " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCCOT) {
			return "(acot " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCCOTH) {
			return "(acoth " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCCSC) {
			return "(acsc " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCCSCH) {
			return "(acsch " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCSEC) {
			return "(asec " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCSECH) {
			return "(asech " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCSIN) {
			return "(asin " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCSINH) {
			return "(asinh " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCTAN) {
			return "(atan " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ARCTANH) {
			return "(atanh " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_CEILING) {
			return "(ceil " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_COS) {
			return "(cos " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_COSH) {
			return "(cosh " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_COT) {
			return "(cot " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_COTH) {
			return "(coth " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_CSC) {
			return "(csc " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_CSCH) {
			return "(csch " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_DELAY) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(delay " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_EXP) {
			return "(exp " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_FACTORIAL) {
			return "(factorial " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_FLOOR) {
			return "(floor " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_LN) {
			return "(ln " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_LOG) {
			String result = "(log ";
			for (int i = 0; i < math.getChildCount(); i++) {
				String child = prefixASTNodeToString(math.getChild(i));
				result += child;
				if (i + 1 < math.getChildCount()) {
					result += " ";
				}
			}
			result += ")";
			return result;
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_PIECEWISE) {
			String result = "(piecewise ";
			for (int i = 0; i < math.getChildCount(); i++) {
				String child = prefixASTNodeToString(math.getChild(i));
				result += child;
				if (i + 1 < math.getChildCount()) {
					result += " ";
				}
			}
			result += ")";
			return result;
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_POWER) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(^ " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_ROOT) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(root " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_SEC) {
			return "(sec " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_SECH) {
			return "(sech " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_SIN) {
			return "(sin " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_SINH) {
			return "(sinh " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_TAN) {
			return "(tan " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.FUNCTION_TANH) {
			return "(tanh " + prefixASTNodeToString(math.getChild(0)) + ")";
		}
		else if (math.getType() == ASTNode.Type.INTEGER) {
			return "" + math.getInteger();
		}
		else if (math.getType() == ASTNode.Type.LOGICAL_AND) {
			if (math.getChildCount() == 0)
				return "";
			String result = "(and ";
			for (int i = 0; i < math.getChildCount(); i++) {
				String child = prefixASTNodeToString(math.getChild(i));
				result += child;
				if (i + 1 < math.getChildCount()) {
					result += " ";
				}
			}
			result += ")";
			return result;
		}
		else if (math.getType() == ASTNode.Type.LOGICAL_NOT) {
			if (math.getChildCount() == 0)
				return "";
			String result = "(not ";
			String child = prefixASTNodeToString(math.getChild(0));
			result += child;
			result += ")";
			return result;
		}
		else if (math.getType() == ASTNode.Type.LOGICAL_OR) {
			if (math.getChildCount() == 0)
				return "";
			String result = "(or ";
			for (int i = 0; i < math.getChildCount(); i++) {
				String child = prefixASTNodeToString(math.getChild(i));
				result += child;
				if (i + 1 < math.getChildCount()) {
					result += " ";
				}
			}
			result += ")";
			return result;
		}
		else if (math.getType() == ASTNode.Type.LOGICAL_XOR) {
			if (math.getChildCount() == 0)
				return "";
			String result = "(xor ";
			for (int i = 0; i < math.getChildCount(); i++) {
				String child = prefixASTNodeToString(math.getChild(i));
				result += child;
				if (i + 1 < math.getChildCount()) {
					result += " ";
				}
			}
			result += ")";
			return result;
		}
		else if (math.getType() == ASTNode.Type.MINUS) {
			if (math.getChildCount() == 1) {
				return "(- 0.0 " + prefixASTNodeToString(math.getChild(0)) + ")";
			}
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(- " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.NAME) {
			return math.getName();
		}
		else if (math.getType() == ASTNode.Type.NAME_AVOGADRO) {
			return "avogadro";
		}
		else if (math.getType() == ASTNode.Type.NAME_TIME) {
			return "t";
		}
		else if (math.getType() == ASTNode.Type.PLUS) {
			String returnVal = "(+ ";
			boolean first = true;
			for (int i = 0; i < math.getChildCount(); i++) {
				if (first) {
					first = false;
				}
				else {
					returnVal += " ";
				}
				returnVal += prefixASTNodeToString(math.getChild(i));
			}
			returnVal += ")";
			return returnVal;
		}
		else if (math.getType() == ASTNode.Type.POWER) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(^ " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.RATIONAL) {
			return "(/ " + math.getNumerator() + " " + math.getDenominator() + ")";
		}
		else if (math.getType() == ASTNode.Type.REAL) {
			return "" + math.getReal();
		}
		else if (math.getType() == ASTNode.Type.REAL_E) {
			return math.getMantissa() + "e" + math.getExponent();
		}
		else if (math.getType() == ASTNode.Type.RELATIONAL_EQ) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(= " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.RELATIONAL_GEQ) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(>= " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.RELATIONAL_GT) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(> " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.RELATIONAL_LEQ) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(<= " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.RELATIONAL_LT) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(< " + leftStr + " " + rightStr + ")";
		}
		else if (math.getType() == ASTNode.Type.RELATIONAL_NEQ) {
			String leftStr = prefixASTNodeToString(math.getLeftChild());
			String rightStr = prefixASTNodeToString(math.getRightChild());
			return "(not (= " + leftStr + " " + rightStr + "))";
		}
		else if (math.getType() == ASTNode.Type.TIMES) {
			String returnVal = "(* ";
			boolean first = true;
			for (int i = 0; i < math.getChildCount(); i++) {
				if (first) {
					first = false;
				}
				else {
					returnVal += " ";
				}
				returnVal += prefixASTNodeToString(math.getChild(i));
			}
			returnVal += ")";
			return returnVal;
		}
		else {
			if (math.isOperator()) {
				System.err.println("Operator " + math.getName() + " is not currently supported.");
			}
			else {
				System.err.println(math.getName() + " is not currently supported.");
			}
		}
		return "";
	}

	public static class Tuple<X, Y> {
		public final X x;
		public final Y y;

		public Tuple(X x, Y y) {
			this.x = x;
			this.y = y;
		}
	}
}
